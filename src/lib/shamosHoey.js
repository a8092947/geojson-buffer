!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).shamosHoey=e()}(this,function(){"use strict";class t{constructor(t=[],e=function(t,e){return t<e?-1:t>e?1:0}){if(this.data=t,this.length=this.data.length,this.compare=e,this.length>0)for(let t=(this.length>>1)-1;t>=0;t--)this._down(t)}push(t){this.data.push(t),this.length++,this._up(this.length-1)}pop(){if(0===this.length)return;const t=this.data[0];return this.length--,this.length>0&&(this.data[0]=this.data[this.length],this._down(0)),this.data.pop(),t}peek(){return this.data[0]}_up(t){const{data:e,compare:n}=this,r=e[t];for(;t>0;){const i=t-1>>1,o=e[i];if(n(r,o)>=0)break;e[t]=o,t=i}e[t]=r}_down(t){const{data:e,compare:n}=this,r=this.length>>1,i=e[t];for(;t<r;){let r=1+(t<<1),o=e[r];const l=r+1;if(l<this.length&&n(e[l],o)<0&&(r=l,o=e[l]),n(o,i)>=0)break;e[t]=o,t=r}e[t]=i}}function e(t,e){return t.x>e.x?1:t.x<e.x?-1:t.y!==e.y?t.y>e.y?1:-1:1}class n{constructor(){return new t([],e)}}class r{constructor(t,e){this.key=t,this.data=e,this.left=null,this.right=null}}function i(t,e,n){if(null===e)return e;let i,o,l;const s=new r;for(i=o=s;;){const r=n(t,e.key);if(r<0){if(null===e.left)break;if(n(t,e.left.key)<0&&(l=e.left,e.left=l.right,l.right=e,null===(e=l).left))break;o.left=e,o=e,e=e.left}else{if(!(r>0))break;if(null===e.right)break;if(n(t,e.right.key)>0&&(l=e.right,e.right=l.left,l.left=e,null===(e=l).right))break;i.right=e,i=e,e=e.right}}return i.right=e.left,o.left=e.right,e.left=s.right,e.right=s.left,e}function o(t,e,n,o,l){const s=new r(t,e);if(l._size++,null===n)return s.left=s.right=null,s;const h=o(t,(n=i(t,n,o)).key);return h<0?(s.left=n.left,s.right=n,n.left=null):h>=0&&(s.right=n.right,s.left=n,n.right=null),s}function l(t,e,n,r){let o;return null===e?null:0===n(t,(e=i(t,e,n)).key)?(null===e.left?o=e.right:(o=i(t,e.left,n)).right=e.right,r._size--,o):e}function s(t,e,n){let r,o;if(null===e)r=o=null;else{const l=n((e=i(t,e,n)).key,t);0===l?(r=e.left,o=e.right):l<0?(o=e.right,e.right=null,r=e):(r=e.left,e.left=null,o=e)}return{left:r,right:o}}class h{constructor(t=function(t,e){return t>e?1:t<e?-1:0}){this._comparator=t,this._root=null,this._size=0}insert(t,e){return this._root=o(t,e,this._root,this._comparator,this)}add(t,e){return this._root=function(t,e,n,o,l){const s=new r(t,e);if(null===n)return s.left=s.right=null,l._size++,s;const h=o(t,(n=i(t,n,o)).key);return 0===h?n:(h<0?(s.left=n.left,s.right=n,n.left=null):h>0&&(s.right=n.right,s.left=n,n.right=null),l._size++,s)}(t,e,this._root,this._comparator,this)}remove(t){this._root=l(t,this._root,this._comparator,this)}pop(){let t=this._root;if(t){for(;t.left;)t=t.left;return this._root=i(t.key,this._root,this._comparator),this._root=l(t.key,this._root,this._comparator,this),{key:t.key,data:t.data}}return null}findStatic(t){let e=this._root;const n=this._comparator;for(;e;){const r=n(t,e.key);if(0===r)return e;e=r<0?e.left:e.right}return null}find(t){return this._root&&(this._root=i(t,this._root,this._comparator),0!==this._comparator(t,this._root.key))?null:this._root}contains(t){let e=this._root;const n=this._comparator;for(;e;){const r=n(t,e.key);if(0===r)return!0;e=r<0?e.left:e.right}return!1}forEach(t,e){let n=this._root;const r=[];let i=!1;for(;!i;)null!==n?(r.push(n),n=n.left):0!==r.length?(n=r.pop(),t.call(e,n),n=n.right):i=!0;return this}range(t,e,n,r){const i=[],o=this._comparator;let l,s=this._root;for(;0!==i.length||s;)if(s)i.push(s),s=s.left;else{if((l=o((s=i.pop()).key,e))>0)break;if(o(s.key,t)>=0&&n.call(r,s))return this;s=s.right}return this}keys(){const t=[];return this.forEach(({key:e})=>t.push(e)),t}values(){const t=[];return this.forEach(({data:e})=>t.push(e)),t}min(){return this._root?this.minNode(this._root).key:null}max(){return this._root?this.maxNode(this._root).key:null}minNode(t=this._root){if(t)for(;t.left;)t=t.left;return t}maxNode(t=this._root){if(t)for(;t.right;)t=t.right;return t}at(t){let e=this._root,n=!1,r=0;const i=[];for(;!n;)if(e)i.push(e),e=e.left;else if(i.length>0){if(e=i.pop(),r===t)return e;r++,e=e.right}else n=!0;return null}next(t){let e=this._root,n=null;if(t.right){for(n=t.right;n.left;)n=n.left;return n}const r=this._comparator;for(;e;){const i=r(t.key,e.key);if(0===i)break;i<0?(n=e,e=e.left):e=e.right}return n}prev(t){let e=this._root,n=null;if(null!==t.left){for(n=t.left;n.right;)n=n.right;return n}const r=this._comparator;for(;e;){const i=r(t.key,e.key);if(0===i)break;i<0?e=e.left:(n=e,e=e.right)}return n}clear(){return this._root=null,this._size=0,this}toList(){return function(t){var e=t,n=[],r=!1;const i={next:null};let o=i;for(;!r;)e?(n.push(e),e=e.left):n.length>0?e=(e=o=o.next=n.pop()).right:r=!0;return o.next=null,i.next}(this._root)}load(t=[],e=[],n=!1){let r=t.length;const i=this._comparator;if(n&&function t(e,n,r,i,o){if(r>=i)return;const l=e[r+i>>1];let s=r-1;let h=i+1;for(;;){do{s++}while(o(e[s],l)<0);do{h--}while(o(e[h],l)>0);if(s>=h)break;let t=e[s];e[s]=e[h],e[h]=t,t=n[s],n[s]=n[h],n[h]=t}t(e,n,r,h,o);t(e,n,h+1,i,o)}(t,e,0,r-1,i),null===this._root)this._root=function t(e,n,r,i,o){const l=o-i;if(l>0){const s=i+Math.floor(l/2),h=n[s],f=r[s],u={key:h,data:f,parent:e};return u.left=t(u,n,r,i,s),u.right=t(u,n,r,s+1,o),u}return null}(this._root,t,e,0,r),this._size=r;else{const n=function(t,e,n=((t,e)=>t-e)){const r={};let i=r,o=t,l=e;for(;null!==o&&null!==l;)n(o.key,l.key)<0?(i.next=o,o=o.next):(i.next=l,l=l.next),i=i.next;null!==o?i.next=o:null!==l&&(i.next=l);return r.next}(this.toList(),function(t,e){const n={next:null};let r=n;for(let n=0;n<t.length;n++)r=r.next={key:t[n],data:e[n]};return r.next=null,n.next}(t,e),i);r=this._size+r,this._root=function t(e,n,r){const i=r-n;if(i>0){const o=n+Math.floor(i/2),l=t(e,n,o),s=e.head;return s.left=l,e.head=e.head.next,s.right=t(e,o+1,r),s}return null}({head:n},0,r)}return this}isEmpty(){return null===this._root}get size(){return this._size}toString(t=(t=>t.key)){const e=[];return function t(e,n,r,i,o){if(e){i(`${n}${r?"└── ":"├── "}${o(e)}\n`);const l=n+(r?"    ":"│   ");e.left&&t(e.left,l,!1,i,o),e.right&&t(e.right,l,!0,i,o)}}(this._root,"",!0,t=>e.push(t),t),e.join("")}update(t,e,n){const r=this._comparator;let{left:l,right:h}=s(t,this._root,r);this._size--,r(t,e)<0?h=o(e,n,h,r,this):l=o(e,n,l,r,this),this._root=function(t,e,n){return null===e?t:null===t?e:((e=i(t.key,e,n)).left=t,e)}(l,h,r)}split(t){return s(t,this._root,this._comparator)}}class f{constructor(t){this.leftSweepEvent=t,this.rightSweepEvent=t.otherEvent,this.segmentAbove=null,this.segmentBelow=null,t.segment=this,t.otherEvent.segment=this}}function u(t,e,n){return(t.x-n.x)*(e.y-n.y)-(e.x-n.x)*(t.y-n.y)}function p(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)}function g(t,n){return t===n?0:0!==u(t.leftSweepEvent,t.rightSweepEvent,n.leftSweepEvent)||0!==u(t.leftSweepEvent,t.rightSweepEvent,n.rightSweepEvent)?t.leftSweepEvent.isSamePoint(n.leftSweepEvent)?t.leftSweepEvent.isBelow(n.rightSweepEvent)?-1:1:t.leftSweepEvent.x===n.leftSweepEvent.x?t.leftSweepEvent.y<n.leftSweepEvent.y?-1:1:1===e(t.leftSweepEvent,n.leftSweepEvent)?n.leftSweepEvent.isAbove(t.leftSweepEvent)?-1:1:t.leftSweepEvent.isBelow(n.leftSweepEvent)?-1:1:1===e(t.leftSweepEvent,n.leftSweepEvent)?1:-1}class a{constructor(t){this.tree=new h(g),this.testIntersect=t?this.booleanTest:this.getPointTest}addSegment(t){const e=new f(t),n=this.tree.insert(e),r=this.tree.next(n),i=this.tree.prev(n);return null!==r&&(e.segmentAbove=r.key,e.segmentAbove.segmentBelow=e),null!==i&&(e.segmentBelow=i.key,e.segmentBelow.segmentAbove=e),n.key}findSegment(t){const e=this.tree.find(t);return null===e?null:e.key}removeSegmentFromSweepline(t){const e=this.tree.find(t);if(null===e)return;const n=this.tree.next(e),r=this.tree.prev(e);if(null!==n){n.key.segmentBelow=t.segmentBelow}if(null!==r){r.key.segmentAbove=t.segmentAbove}this.tree.remove(t)}booleanTest(t,e){if(null===t||null===e)return!1;if(t.rightSweepEvent.isSamePoint(e.leftSweepEvent)||t.rightSweepEvent.isSamePoint(e.rightSweepEvent)||t.leftSweepEvent.isSamePoint(e.leftSweepEvent)||t.leftSweepEvent.isSamePoint(e.rightSweepEvent))return!1;let n,r;return!((n=p(t.leftSweepEvent,t.rightSweepEvent,e.leftSweepEvent))*(r=p(t.leftSweepEvent,t.rightSweepEvent,e.rightSweepEvent))>0)&&!((n=p(e.leftSweepEvent,e.rightSweepEvent,t.leftSweepEvent))*(r=p(e.leftSweepEvent,e.rightSweepEvent,t.rightSweepEvent))>0)}getPointTest(t,e){if(null===t||null===e)return!1;if(t.rightSweepEvent.isSamePoint(e.leftSweepEvent)||t.rightSweepEvent.isSamePoint(e.rightSweepEvent)||t.leftSweepEvent.isSamePoint(e.leftSweepEvent)||t.leftSweepEvent.isSamePoint(e.rightSweepEvent))return!1;const n=t.leftSweepEvent.x,r=t.leftSweepEvent.y,i=t.rightSweepEvent.x,o=t.rightSweepEvent.y,l=e.leftSweepEvent.x,s=e.leftSweepEvent.y,h=e.rightSweepEvent.x,f=e.rightSweepEvent.y,u=(f-s)*(i-n)-(h-l)*(o-r),p=(h-l)*(r-s)-(f-s)*(n-l),g=(i-n)*(r-s)-(o-r)*(n-l);if(0===u)return!1;const a=p/u,c=g/u;if(a>=0&&a<=1&&c>=0&&c<=1){return{x:n+a*(i-n),y:r+a*(o-r),segmentIndices:[t.leftSweepEvent.segmentIndex,e.leftSweepEvent.segmentIndex],segments:[[[t.leftSweepEvent.x,t.leftSweepEvent.y],[t.rightSweepEvent.x,t.rightSweepEvent.y]],[[e.leftSweepEvent.x,e.leftSweepEvent.y],[e.rightSweepEvent.x,e.rightSweepEvent.y]]]}}return!1}}class c{constructor(t){this.x=t[0],this.y=t[1],this.otherEvent=null,this.isLeftEndpoint=null,this.segment=null,this.segmentIndex=null}isOtherEndOfSegment(t){return this===t.otherEvent}isSamePoint(t){return this.x===t.x&&this.y===t.y}isBelow(t){return this.isLeftEndpoint?u(this,this.otherEvent,t)>0:u(this.otherEvent,t,this)>0}isAbove(t){return!this.isBelow(t)}}return function(t,r){null==r&&(r={}),null==r.booleanOnly&&(r.booleanOnly=!0);const i=[],o=new n;!function(t,n){const r="Feature"===t.type?t.geometry:t;let i=r.coordinates;"Polygon"!==r.type&&"MultiLineString"!==r.type||(i=[i]),"LineString"===r.type&&(i=[[i]]);let o=0;for(let t=0;t<i[0].length;t++)for(let r=0;r<i[0][t].length-1;r++){const l=new c(i[0][t][r]),s=new c(i[0][t][r+1]);l.segmentIndex=o,s.segmentIndex=o,l.otherEvent=s,s.otherEvent=l,e(l,s)>0?(s.isLeftEndpoint=!0,l.isLeftEndpoint=!1):(l.isLeftEndpoint=!0,s.isLeftEndpoint=!1),n.push(l),n.push(s),++o}}(t,o);const l=new a(r.booleanOnly);let s=null;for(;o.length;){const t=o.pop();if(t.isLeftEndpoint){s=l.addSegment(t);const e=l.testIntersect(s,s.segmentAbove);if(!1!==e){if(r.booleanOnly)return!1;i.push(e)}const n=l.testIntersect(s,s.segmentBelow);if(n){if(r.booleanOnly)return!1;i.push(n)}}else{const e=l.testIntersect(t.segment.segmentAbove,t.segment.segmentBelow);if(e){if(r.booleanOnly)return!1;i.push(e)}l.removeSegmentFromSweepline(t.segment)}}return!!r.booleanOnly||i}});
